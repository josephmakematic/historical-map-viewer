<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Historical Map Viewer - OpenHistoricalMap</title>
  <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css"/>
  <style>
    html, body { 
      height: 100%; 
      margin: 0; 
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
    }
    #map { 
      position: absolute; 
      inset: 0; 
    }

    .controls {
      position: absolute; 
      top: 20px; 
      left: 20px; 
      background: #333f48; 
      color: #fff;
      padding: 20px; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0,0,0,.2);
      z-index: 1000; 
      max-width: 340px;
    }
    .controls h3 { 
      margin: 0 0 12px 0; 
      font-size: 16px; 
      color: #FF671F; 
    }
    .instructions-heading { 
      font-size: 13px; 
      color: #ccc; 
      line-height: 1.4; 
      margin: -5px 0 5px 0; 
      font-weight: bold; 
    }
    .instructions-list { 
      font-size: 13px; 
      color: #ccc; 
      line-height: 1.4; 
      margin: 0 0 15px 0; 
      padding-left: 20px; 
    }
    .instructions-list li { 
      margin-bottom: 5px; 
    }
    .instructions-list a { 
      color: #FF671F; 
      text-decoration: underline; 
    }
    .instructions-list a:hover { 
      color: #fff; 
    }
    .date-input { 
      margin-bottom: 15px; 
    }
    .date-input label { 
      display: block; 
      margin-bottom: 5px; 
      font-size: 14px; 
      color: #f0f0f0; 
    }
    .date-input input, 
    .resolution-select {
      width: 100%; 
      padding: 8px; 
      border: 1px solid #FF671F; 
      background: #4a555e; 
      color:#fff;
      border-radius: 4px; 
      font-size:14px; 
      box-sizing: border-box;
    }
    .button-group { 
      display: flex; 
      gap: 10px; 
      margin-top: 12px; 
    }
    button { 
      flex: 1; 
      padding: 10px; 
      background: #08a184; 
      color: #fff; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
      font-size:14px; 
      transition: background .3s; 
    }
    button:hover { 
      background: #45a049; 
    }
    button.secondary, 
    button.tertiary { 
      background: #FF671F; 
    }
    button.secondary:hover, 
    button.tertiary:hover { 
      background: #E65C1A; 
    }
    .current-date { 
      margin-top: 10px; 
      padding: 10px; 
      background: #4a555e; 
      border-radius: 4px; 
      font-size: 13px; 
      color: #f0f0f0; 
    }
    .export-options { 
      margin-top: 15px; 
      padding-top: 15px; 
      border-top: 1px solid #FF671F; 
    }
    .export-options h4 { 
      margin: 0 0 8px 0; 
      font-size: 14px; 
      color: #FF671F; 
    }
    .svg-options { 
      margin-top: 12px; 
    }
    .svg-options label { 
      display: block; 
      font-size: 12px; 
      color: #f0f0f0; 
      margin: 8px 0 0 0; 
    }
    .loading { 
      display:none; 
      position:absolute; 
      top:50%; 
      left:50%; 
      transform:translate(-50%,-50%); 
      z-index:2000; 
      background:white; 
      padding:20px; 
      border-radius:8px; 
      box-shadow:0 2px 10px rgba(0,0,0,.2); 
    }
    .loading.active { 
      display:block; 
    }
    .spinner { 
      border:3px solid #f3f3f3; 
      border-top:3px solid #3498db; 
      border-radius:50%; 
      width:40px; 
      height:40px; 
      animation:spin 1s linear infinite; 
      margin:0 auto 10px; 
    }
    @keyframes spin { 
      0%{transform:rotate(0)} 
      100%{transform:rotate(360deg)} 
    }
    .inline-check { 
      display:flex; 
      align-items:center; 
      gap:8px; 
      font-size:12px; 
      color:#eaeaea; 
      margin-top:6px; 
    }
    .inline-check input { 
      width:16px; 
      height:16px; 
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="controls">
    <h3>Makematic Historical Map Viewer</h3>
    <p class="instructions-heading">Instructions:</p>
    <ol class="instructions-list">
      <li>Go full screen with your browser. Do not move or zoom in on the map.</li>
      <li>Enter the correct date, and then wait until the map is fully populated with national borders.</li>
      <li>Export borders (SVG) for your animator.</li>
      <li>Download the base map <a href="https://raw.githubusercontent.com/josephmakematic/historical-map-viewer/refs/heads/main/natural-earth-basemap-final.jpg">here</a> if needed.</li>
    </ol>

    <div class="date-input">
      <label for="date">Select Date:</label>
      <input type="date" id="date" value="1939-09-01" min="1800-01-01" max="2024-12-31">
    </div>

    <button onclick="updateMap()">Update Map</button>
    <div class="current-date">Current view: <strong id="currentDate">September 1, 1939</strong></div>

    <div class="export-options">
      <h4>Export Map</h4>
      <select class="resolution-select" id="resolution">
        <option value="1">Current View (1x)</option>
        <option value="2">High Resolution (2x)</option>
        <option value="4">Very High Resolution (4x)</option>
      </select>
      <div class="button-group">
        <button class="secondary" onclick="exportPNG()">Export PNG</button>
      </div>

      <div class="svg-options">
        <label>SVG Vector Export:</label>
        <div class="inline-check">
          <input type="checkbox" id="alsoTxt" checked />
          <span>Also download credits/license report (.txt)</span>
        </div>
        <div class="button-group">
          <button class="tertiary" onclick="exportSVG()">Export Borders (SVG)</button>
        </div>
      </div>
    </div>
  </div>

  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div>Exporting…</div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <script>
    let map;
    let currentDecimalDate = 1939 + (244 / 365); // September 1, 1939

    // Fixed export area + output size
    const exportBounds = new maplibregl.LngLatBounds([-180, -60], [180, 85]);
    const exportWidth = 3000;
    const exportHeight = 1650;

    function waitForMapIdle() {
      return new Promise(resolve => {
        if (map.loaded() && map.areTilesLoaded()) resolve();
        else map.once('idle', resolve);
      });
    }

    function dateToDecimalYear(dateStr) {
      const d = new Date(dateStr);
      const y = d.getFullYear();
      const start = new Date(y, 0, 1);
      const dayOfYear = Math.floor((d - start) / (1000 * 60 * 60 * 24)) + 1;
      const daysInYear = ((y % 4 === 0 && y % 100 !== 0) || (y % 400 === 0)) ? 366 : 365;
      return y + (dayOfYear / daysInYear);
    }

    function formatDate(dateStr) {
      return new Date(dateStr).toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    }

    function initMap() {
      const style = {
        version: 8,
        sources: {
          ohm: { type: "vector", tiles: ["https://vtiles.openhistoricalmap.org/maps/osm/{z}/{x}/{y}.pbf"], attribution: "© OpenHistoricalMap contributors" },
          "natural-earth": {
            type: "raster",
            tiles: ["https://klokantech.github.io/naturalearthtiles/tiles/natural_earth_2_shaded_relief.raster/{z}/{x}/{y}.png"],
            tileSize: 256,
            attribution: "Natural Earth (Public Domain)"
          }
        },
        layers: [
          { id: "background", type: "background", paint: { "background-color": "#a8cceb" } },
          { id: "base", type: "raster", source: "natural-earth", paint: { "raster-opacity": 1 } },
          { id: "borders", type: "line", source: "ohm", "source-layer": "land_ohm_lines", paint: { "line-color": "#222", "line-width": 2 } }
        ]
      };

      map = new maplibregl.Map({
        container: "map",
        style,
        center: [10, 30],
        zoom: 1.5,
        preserveDrawingBuffer: true
      });

      map.on("load", () => {
        map.fitBounds(exportBounds, { padding: 20, duration: 0 });
        applyDateFilter();
      });
    }

    function applyDateFilter() {
      const filter = [
        "all",
        ["<=", ["coalesce", ["get", "start_decdate"], -999999], currentDecimalDate],
        ["any",
          ["!", ["has", "end_decdate"]],
          [">=", ["coalesce", ["get", "end_decdate"], 999999], currentDecimalDate]
        ]
      ];
      if (map.getLayer("borders")) map.setFilter("borders", filter);
    }

    function updateMap() {
      const dateInput = document.getElementById('date').value;
      currentDecimalDate = dateToDecimalYear(dateInput);
      document.getElementById('currentDate').textContent = formatDate(dateInput);
      if (map.loaded()) applyDateFilter();
    }

    function exportPNG() {
      const scale = parseInt(document.getElementById('resolution').value);
      const canvas = map.getCanvas();
      const exportCanvas = document.createElement('canvas');
      const width = canvas.width * scale;
      const height = canvas.height * scale;
      exportCanvas.width = width;
      exportCanvas.height = height;
      const ctx = exportCanvas.getContext('2d');
      ctx.scale(scale, scale);
      ctx.drawImage(canvas, 0, 0);
      exportCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `historical-map-${document.getElementById('date').value}.png`;
        a.click();
        URL.revokeObjectURL(url);
      });
    }

    function setLoading(isLoading) {
      document.getElementById('loading').classList.toggle('active', isLoading);
    }

    function escapeXML(str) {
      if (typeof str !== 'string') return '';
      return str.replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;',"'":'&apos;','"':'&quot;'}[c]));
    }

    // -------- Export SVG (plus optional TXT) ----------
    async function exportSVG() {
      setLoading(true);
      try {
        await waitForMapIdle();

        const sw = map.project(exportBounds.getSouthWest());
        const ne = map.project(exportBounds.getNorthEast());

        const minX = Math.min(sw.x, ne.x);
        const maxX = Math.max(sw.x, ne.x);
        const minY = Math.min(sw.y, ne.y);
        const maxY = Math.max(sw.y, ne.y);

        const bbox = [[minX, minY], [maxX, maxY]];
        
        const features = map.queryRenderedFeatures(bbox, { layers: ['borders'] });

        const foundLicenses = new Set();
        const foundAttributions = new Set();
        const addedPaths = new Set();
        
        const borderPaths = createSVGPathsFromFeatures(features, exportBounds, exportWidth, exportHeight, addedPaths, foundLicenses, foundAttributions);

        // *** MODIFIED: Pass all Sets to assembleSVG ***
        const { svgContent, svgTitle } = assembleSVG(borderPaths, exportWidth, exportHeight, foundLicenses, foundAttributions);

        // Download the SVG
        downloadBlob(svgContent, `historical-map-${document.getElementById('date').value}-borders-only.svg`, 'image/svg+xml');

        // Optional: also download a text credits file
        if (document.getElementById('alsoTxt').checked) {
          // *** MODIFIED: Pass all Sets to buildCreditsText ***
          const credits = buildCreditsText(svgTitle, foundLicenses, foundAttributions);
          downloadBlob(credits, `historical-map-${document.getElementById('date').value}-credits.txt`, 'text/plain');
        }
      } catch (e) {
        console.error("Error exporting SVG:", e);
      } finally {
        setLoading(false);
      }
    }

    function downloadBlob(content, filename, mime) {
      const blob = new Blob([content], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    // *** MODIFIED: This function now generates the clear animator instructions ***
    function buildCreditsText(svgTitle, foundLicenses, foundAttributions) {
      const now = new Date().toISOString();
      const credits = [
        "Makematic Historical Map Viewer — Credits",
        "----------------------------------------",
        `Title: ${svgTitle}`,
        `Exported: ${now}`,
        "",
      ];

      // --- New Animator Instructions Logic ---
      credits.push("Animator Instructions:");
      
      if (foundLicenses.size === 0 && foundAttributions.size === 0) {
        // Case 1: No licenses, no attributions
        credits.push("Summary: No license or attribution tags found. Features are likely CC0 (Public Domain).");
        credits.push("Action: No attribution required.");
      } else {
        // Case 2: Licenses or attributions found
        credits.push("Summary: One or more features have specific license or attribution requirements.");
        credits.push("Action: Please see details below.");
        credits.push(""); // Add a space

        if (foundLicenses.size > 0) {
          credits.push("Found Licenses:");
          foundLicenses.forEach(license => {
            credits.push(`  - ${license}`);
          });
          credits.push(""); // Add a space
        }

        if (foundAttributions.size > 0) {
          credits.push("Required Attribution:");
          foundAttributions.forEach(attr => {
            credits.push(`  - ${attr}`);
          });
          credits.push(""); // Add a space
        } else if (foundLicenses.size > 0) {
            // Case where a license like 'CC BY' exists but has no matching 'attribution' tag
            credits.push("Required Attribution:");
            credits.push("  - No specific 'attribution=*' tag found. Please credit 'OpenHistoricalMap contributors' as per the license terms.");
            credits.push(""); // Add a space
        }
      }
      // --- End of New Logic ---

      credits.push(
        "----------------------------------------",
        "Source:",
        "  OpenHistoricalMap — https://www.openhistoricalmap.org",
        "",
        "Notes:",
        "  This text file was generated automatically by the app alongside the SVG.",
        "  If license=* or attribution=* values exist on exported features, they are listed above.",
        ""
      );
      
      return credits.join("\n");
    }

    function createSVGPathsFromFeatures(features, bounds, width, height, addedPaths, foundLicenses, foundAttributions) {
      const sw = map.project(bounds.getSouthWest());
      const ne = map.project(bounds.getNorthEast());

      const projectedWidth = ne.x - sw.x;
      const projectedHeight = sw.y - ne.y;
      const scale = Math.min(width / projectedWidth, height / projectedHeight);

      const pxTop = ne.y;
      const pxLeft = sw.x;
      const offsetX = (width - (projectedWidth * scale)) / 2;
      const offsetY = (height - (projectedHeight * scale)) / 2;

      let borderLines = '';

      function createPathLine(line) {
        return line.map((coord, i) => {
          if (!coord || coord.length < 2) return '';
          const px = map.project(coord);
          const svgX = ((px.x - pxLeft) * scale) + offsetX;
          const svgY = ((px.y - pxTop) * scale) + offsetY;
          return `${i === 0 ? 'M' : 'L'}${svgX.toFixed(2)},${svgY.toFixed(2)}`;
        }).join(' ');
      }

      features.forEach(feature => {
        // Collect license=*
        const license = feature.properties?.license;
        if (license) foundLicenses.add(license);
        
        // Collect attribution=*
        const attribution = feature.properties?.attribution;
        if (attribution) foundAttributions.add(attribution);

        const geom = feature.geometry;
        if (feature.layer.id === 'borders') {
          let paths = [];
          if (geom.type === 'LineString') {
            paths.push(createPathLine(geom.coordinates));
          } else if (geom.type === 'MultiLineString') {
            geom.coordinates.forEach(line => paths.push(createPathLine(line)));
          }
          paths.forEach(d => {
            if (d && !addedPaths.has(d)) { addedPaths.add(d); borderLines += `<path d="${d}" />\n`; }
          });
        }
      });

      return borderLines;
    }

    function assembleSVG(borderPaths, width, height, foundLicenses, foundAttributions) {
      
      // *** MODIFIED: Build a clear description for SVG metadata ***
      let svgDesc;
      if (foundLicenses.size === 0 && foundAttributions.size === 0) {
        svgDesc = "No license or attribution tags found. Features are likely CC0 (Public Domain). No attribution required.";
      } else {
        let licenseString = "";
        if (foundLicenses.size > 0) {
          licenseString = `Found licenses: ${Array.from(foundLicenses).join(", ")}.`;
        } else {
          licenseString = "No license tags found.";
        }

        let attrString = "";
        if (foundAttributions.size > 0) {
          attrString = `Required attribution: ${Array.from(foundAttributions).join(", ")}.`;
        } else if (foundLicenses.size > 0) {
          attrString = "Required attribution: No specific 'attribution=*' tag found, please credit 'OpenHistoricalMap contributors'.";
        }
        
        svgDesc = `${licenseString} ${attrString}`.trim();
      }
      // --- End of new logic ---

      const fileDate = document.getElementById('date').value;
      const nowISO = new Date().toISOString();
      const svgTitle = `OpenHistoricalMap Borders — ${fileDate}`;

      // Standards-friendly metadata (<title>/<desc> + simple RDF)
      const rdfMetadata = `
  <metadata>
    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
             xmlns:dc="http://purl.org/dc/elements/1.1/">
      <rdf:Description rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:title>${escapeXML(svgTitle)}</dc:title>
        <dc:description>${escapeXML(svgDesc)}</dc:description>
        <dc:creator>OpenHistoricalMap contributors</dc:creator>
        <dc:date>${escapeXML(nowISO)}</dc:date>
      </rdf:Description>
    </rdf:RDF>
  </metadata>`.trim();

      // Hidden in-artwork credits payload
      const hiddenCredits = `
  <g id="credits" style="display:none">
    <text x="10" y="20" xml:space="preserve">${escapeXML(svgDesc)}</text>
  </g>`.trim();

      const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}"
     xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 ${width} ${height}">
  <title>${escapeXML(svgTitle)}</title>
  <desc>${escapeXML(svgDesc)}</desc>
  ${rdfMetadata}

  <!-- Human-readable comment for text editors -->
  <!-- ${escapeXML(svgDesc)} -->

  <rect fill="#ffffff" width="${width}" height="${height}"/>

  <g id="borders"
     stroke="#222222"
     stroke-width="0.5"
     fill="none"
     stroke-linejoin="round"
     stroke-linecap="round"
     vector-effect="non-scaling-stroke">
${borderPaths}
  </g>

  ${hiddenCredits}
</svg>`;

      // *** MODIFIED: Cleaned up return object ***
      return { svgContent, svgTitle };
    }

    initMap();
  </script>
</body>
</html>
